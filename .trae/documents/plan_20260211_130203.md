### 1. 确认算法正确性 (Algorithm Verified)
根据您提供的历史对账记录 (`plan_20260211_103819.md`)，`(总额 ± 净额) / 2` 这一反推算法**实际上是被验证过准确的**（误差 < 5%）。
**那么，为什么您现在觉得“结果跟之前不一样”？**
极有可能是因为我最近的代码在处理 `r0` (超大单) 和 `r1` (大单) 的**聚合方式**上出了偏差。
之前的逻辑可能是：`主力 = 超大单 + 大单`。
而现在的代码里，我虽然计算了 `r0_in` 和 `r1_in`，但在最终赋值 `main_buy` 时，可能没有正确地把它们加起来，或者在某些边界条件下（如 `r1` 缺失时）处理得不对。

### 2. 修复计划：严格还原聚合逻辑
我将仔细检查 `server.py` 中的 `main_buy = r0_in + r1_in` 这一步。
同时，为了彻底解决“股价线丢失”的问题，我将在前端 `App.tsx` 中把 `close` 价格线加回去。

### 3. 执行步骤
1.  **后端 (`server.py`)**:
    *   **保持反推算法不变**（因为已验证准确）。
    *   **增强健壮性**: 确保 `r0` 和 `r1` 即使缺失一个也能正常计算，而不是直接跳过或报错。
    *   **显式返回**: 明确返回 `close` 字段，确保前端能拿到股价。
2.  **前端 (`App.tsx`)**:
    *   **恢复双轴图表**: 在“主力净流入”图表中，增加右侧 Y 轴，并画出 `dataKey="close"` 的折线。
    *   **恢复图例**: 确保图例中包含“收盘价”。

这次我们将严格按照“已验证的对账逻辑”来锁定代码，确保数据不再漂移。准备好了吗？